<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ThorVG WebCanvas - Scene Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        #canvas {
            border: 1px solid #333;
            background: white;
            margin: 20px 0;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        .info {
            background: #fff;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>ThorVG WebCanvas - Scene Example</h1>

    <div class="info">
        <h3>Scene API Features:</h3>
        <ul>
            <li>Hierarchical composition - group multiple paints into a scene</li>
            <li>Transform groups - apply transformations to entire scene</li>
            <li>Nested scenes - scenes can contain other scenes</li>
            <li>Scene-level opacity and blending</li>
        </ul>
    </div>

    <div class="controls">
        <label>Backend:
            <select id="backend">
                <option value="sw">Software</option>
                <option value="gl">WebGL</option>
                <option value="wg">WebGPU</option>
            </select>
        </label>
        <button onclick="initAndDraw()">Initialize & Draw Scene</button>
        <button onclick="clearCanvas()">Clear</button>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="info">
        <h3>Status:</h3>
        <pre id="log"></pre>
    </div>

    <script type="module">
        let TVG = null;
        let canvas = null;

        function log(msg) {
            const logEl = document.getElementById('log');
            logEl.textContent += msg + '\n';
            console.log(msg);
        }

        window.initAndDraw = async function() {
            try {
                const renderer = document.getElementById('backend').value;
                log(`\n=== Initializing with ${renderer} backend ===`);

                // Step 1: Initialize ThorVG with backend
                if (!TVG) {
                    log('1. Loading ThorVG WASM module and initializing engine...');
                    const ThorVG = await import('../packages/webcanvas/dist/webcanvas.esm.js');
                    TVG = await ThorVG.init({
                        renderer: renderer,
                        locateFile: (path) => {
                            log(`   locateFile: ${path}`);
                            return '../packages/webcanvas/dist/' + path.split('/').pop();
                        }
                    });
                    log('✓ Module loaded and engine initialized');
                }

                // Step 2: Create canvas
                log('2. Creating canvas...');
                if (canvas) {
                    canvas.clear();
                }
                canvas = new TVG.Canvas('#canvas', {
                    width: 800,
                    height: 600,
                    renderer: renderer
                });
                log('✓ Canvas created');

                // Step 3: Draw scene hierarchy
                log('3. Drawing scene hierarchy...');

                // Create main scene
                const mainScene = new TVG.Scene();
                log('Created main scene');

                // Sub-scene 1: Two circles
                const subScene1 = new TVG.Scene();

                const circle1 = new TVG.Shape();
                circle1.appendCircle(0, 0, 50, 50);
                circle1.fill(255, 100, 100, 255);

                const circle2 = new TVG.Shape();
                circle2.appendCircle(80, 0, 50, 50);
                circle2.fill(100, 255, 100, 255);

                subScene1.add(circle1, circle2);
                subScene1.translate(150, 150);
                log('Added sub-scene 1 with 2 circles');

                // Sub-scene 2: Two rectangles with rotation
                const subScene2 = new TVG.Scene();

                const rect1 = new TVG.Shape();
                rect1.appendRect(0, 0, 80, 60, { rx: 10, ry: 10 });
                rect1.fill(100, 100, 255, 255);

                const rect2 = new TVG.Shape();
                rect2.appendRect(100, 0, 60, 80, { rx: 10, ry: 10 });
                rect2.fill(255, 255, 100, 255);

                subScene2.add(rect1, rect2);
                subScene2.translate(400, 200);
                subScene2.rotate(15); // Rotate the entire sub-scene
                log('Added sub-scene 2 with 2 rectangles (rotated 15°)');

                // Nested scene: Multiple triangular stars
                const nestedScene = new TVG.Scene();

                for (let i = 0; i < 5; i++) {
                    const star = new TVG.Shape();
                    // Simple star shape (triangle)
                    star.moveTo(0, -20);
                    star.lineTo(15, 20);
                    star.lineTo(-15, 20);
                    star.close();

                    // Calculate color based on position
                    const hue = i * 70;
                    const r = Math.floor(255 * Math.abs(Math.sin(hue * Math.PI / 180)));
                    const g = Math.floor(255 * Math.abs(Math.sin((hue + 120) * Math.PI / 180)));
                    const b = Math.floor(255 * Math.abs(Math.sin((hue + 240) * Math.PI / 180)));
                    star.fill(r, g, b, 255);

                    star.translate(i * 40, 0);
                    nestedScene.add(star);
                }

                nestedScene.translate(250, 400);
                nestedScene.opacity(0.78); // Semi-transparent scene (200/255)
                log('Added nested scene with 5 stars (semi-transparent)');

                // Add gradient shape to demonstrate more features
                const gradientShape = new TVG.Shape();
                gradientShape.appendRect(50, 400, 150, 100, { rx: 5, ry: 5 });

                const gradient = new TVG.LinearGradient(0, 0, 150, 0);
                gradient.addStop(0.0, [255, 0, 0, 255]);
                gradient.addStop(0.5, [255, 255, 0, 255]);
                gradient.addStop(1.0, [0, 0, 255, 255]);
                gradient.spread('pad');

                gradientShape.fill(gradient);
                gradientShape.stroke({ width: 3, color: [0, 0, 0, 255] });
                log('Added gradient shape');

                // Add all scenes and shapes to main scene
                mainScene.add(subScene1, subScene2, nestedScene);

                // Add main scene and standalone gradient shape to canvas
                canvas.add(mainScene, gradientShape);
                canvas.render();

                log('✓ Scene rendering complete!');
                log('Hierarchy: Canvas -> [MainScene -> [SubScene1, SubScene2, NestedScene], GradientShape]');

            } catch (error) {
                log('ERROR: ' + error.message);
                console.error(error);
            }
        };

        window.clearCanvas = function() {
            if (!canvas) {
                log('ERROR: Canvas not initialized!');
                return;
            }
            log('Clearing canvas...');
            canvas.clear();
            log('✓ Canvas cleared');
        };

        // Apply renderer from query string
        const params = new URLSearchParams(window.location.search);
        const renderer = params.get('renderer');
        if (renderer && ['sw', 'gl', 'wg'].includes(renderer)) {
            document.getElementById('backend').value = renderer;
        }

        // Handle backend change
        document.getElementById('backend').addEventListener('change', (e) => {
            const url = new URL(window.location.href);
            url.searchParams.set('renderer', e.target.value);
            window.location.href = url.toString();
        });

        log('Ready! Click "Initialize & Draw Scene" to start.');
    </script>
</body>
</html>
