<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ThorVG WebCanvas - Animation Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        #canvas {
            border: 1px solid #333;
            background: white;
            margin: 20px 0;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        .info {
            background: #fff;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        input[type="file"] {
            margin: 5px 0;
        }
        .playback-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        #timeline {
            flex: 1;
            min-width: 300px;
        }
        .frame-info {
            display: inline-block;
            min-width: 200px;
            font-family: monospace;
        }
        .loop-control {
            margin-left: 20px;
        }
    </style>
</head>
<body>
    <h1>ThorVG WebCanvas - Animation API Example</h1>

    <div class="info">
        <h3>Animation API Features:</h3>
        <ul>
            <li>Load and play Lottie animations with <code>Animation.load()</code> or <code>Animation.loadFile()</code></li>
            <li>Playback control: <code>.play()</code>, <code>.pause()</code>, <code>.stop()</code></li>
            <li>Frame-by-frame control with <code>.frame()</code></li>
            <li>Timeline scrubbing with slider</li>
            <li>Loop control with <code>.setLoop()</code></li>
            <li>Get animation info: total frames, duration, FPS</li>
            <li>Frame callback for custom rendering logic</li>
        </ul>
    </div>

    <div class="controls">
        <label>Backend:
            <select id="backend">
                <option value="sw">Software</option>
                <option value="gl">WebGL</option>
                <option value="wg">WebGPU</option>
            </select>
        </label>
        <button onclick="init()">Initialize</button>
        <br>
        <label>Load Lottie File:
            <input type="file" id="fileInput" accept=".json,.lottie" onchange="loadLottieFile(event)">
        </label>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="playback-controls">
        <button id="playBtn" onclick="playPause()">▶ Play</button>
        <button onclick="stop()">⏹ Stop</button>
        <button onclick="prevFrame()">⏮ Prev</button>
        <button onclick="nextFrame()">⏭ Next</button>
        <input type="range" id="timeline" min="0" max="100" value="0" oninput="seekFrame(this.value)">
        <span class="frame-info" id="frameInfo">0.0 / 0 (0.00s)</span>
        <label class="loop-control">
            <input type="checkbox" id="loopCheckbox" checked onchange="toggleLoop()">
            Loop
        </label>
    </div>

    <div class="info">
        <h3>Status:</h3>
        <pre id="log"></pre>
    </div>

    <script type="module">
        import ThorVG from '../packages/webcanvas/dist/webcanvas.esm.js';

        let TVG;
        let canvas;
        let animation;
        let staticScene = null;

        function log(msg) {
            const logEl = document.getElementById('log');
            logEl.textContent += msg + '\n';
            console.log(msg);
        }

        function buildStaticScene() {
            if (!TVG || !canvas) return;

            // Create a static background scene to show layering
            staticScene = new TVG.Scene();

            // Background panel with shadow
            const panelShadow = new TVG.Shape();
            panelShadow.appendRect(0, 0, 760, 560, { rx: 38, ry: 38 })
                .fill(180, 184, 193, 180)
                .translate(26, 26);
            staticScene.add(panelShadow);

            const panel = new TVG.Shape();
            panel.appendRect(0, 0, 760, 560, { rx: 32, ry: 32 })
                .fill(255, 255, 255)
                .translate(20, 20);
            staticScene.add(panel);

            // Grid lines
            for (let y = 120; y <= 520; y += 80) {
                const hLine = new TVG.Shape();
                hLine.appendRect(0, 0, 720, 1.5)
                    .fill(223, 226, 235)
                    .translate(40, y);
                staticScene.add(hLine);
            }

            for (let x = 160; x <= 680; x += 130) {
                const vLine = new TVG.Shape();
                vLine.appendRect(0, 0, 2, 480)
                    .fill(230, 233, 240)
                    .translate(x, 60);
                staticScene.add(vLine);
            }

            // Accent shapes
            const accentRect = new TVG.Shape();
            accentRect.appendRect(0, 0, 180, 110, { rx: 18, ry: 18 })
                .fill(0, 153, 255, 200)
                .translate(80, 80);
            staticScene.add(accentRect);

            const accentRect2 = new TVG.Shape();
            accentRect2.appendRect(0, 0, 140, 70, { rx: 16, ry: 16 })
                .fill(255, 133, 0, 200)
                .translate(540, 360);
            staticScene.add(accentRect2);

            const badge = new TVG.Shape();
            badge.appendCircle(0, 0, 60)
                .fill(64, 64, 255, 220)
                .stroke({ width: 6, color: [255, 255, 255, 255] })
                .translate(640, 170);
            staticScene.add(badge);

            // Timeline overlay
            const timelineTrack = new TVG.Shape();
            timelineTrack.appendRect(0, 0, 640, 14, { rx: 7, ry: 7 })
                .fill(210, 214, 224)
                .translate(80, 500);
            staticScene.add(timelineTrack);

            const timelineProgress = new TVG.Shape();
            timelineProgress.appendRect(0, 0, 360, 14, { rx: 7, ry: 7 })
                .fill(0, 153, 255)
                .translate(80, 500);
            staticScene.add(timelineProgress);

            const timelineKnob = new TVG.Shape();
            timelineKnob.appendCircle(0, 0, 18)
                .fill(255, 255, 255)
                .stroke({ width: 4, color: [0, 153, 255, 255] })
                .translate(440, 507);
            staticScene.add(timelineKnob);

            canvas.add(staticScene);
        }

        function resetCanvasContents() {
            if (!canvas) return;
            canvas.clear();
            buildStaticScene();
            canvas.render();
        }

        window.init = async function() {
            const renderer = document.getElementById('backend').value;
            log(`Initializing ThorVG with ${renderer} backend...`);

            try {
                // Initialize ThorVG with backend
                TVG = await ThorVG.init({
                    renderer: renderer,
                    locateFile: (path) => '../packages/webcanvas/dist/' + path.split('/').pop()
                });

                // Create canvas
                canvas = new TVG.Canvas('#canvas', {
                    renderer: renderer,
                    width: 800,
                    height: 600
                });

                log('✓ ThorVG initialized successfully!');
                resetCanvasContents();
                log('✓ Canvas primed with static scene. Ready to load animation!');
            } catch (error) {
                log('ERROR: ' + error.message);
            }
        };

        window.loadLottieFile = async function(event) {
            if (!canvas) {
                log('ERROR: Canvas not initialized. Click Initialize first!');
                return;
            }

            const file = event.target.files[0];
            if (!file) return;

            log(`Loading Lottie file: ${file.name}...`);

            // Clear previous animation
            if (animation) {
                animation.stop();
                animation.dispose();
                animation = null;
            }

            resetCanvasContents();

            try {
                // User handles file reading
                const arrayBuffer = await file.arrayBuffer();
                const lottieData = new Uint8Array(arrayBuffer);

                // Create new animation
                animation = new TVG.Animation();

                // Load the Lottie data
                animation.load(lottieData);

                // Get animation info
                const info = animation.info();
                log(`Animation loaded: ${info.totalFrames.toFixed(0)} frames, ${info.duration.toFixed(2)}s, ${info.fps.toFixed(2)} FPS`);

                // Get the picture from animation
                const picture = animation.picture;
                if (!picture) {
                    throw new Error('Failed to get picture from animation');
                }

                // Fit animation to canvas
                const originalSize = picture.size();
                const maxWidth = 700;
                const maxHeight = 550;
                const scale = Math.min(maxWidth / originalSize.width, maxHeight / originalSize.height);
                const newWidth = originalSize.width * scale;
                const newHeight = originalSize.height * scale;

                picture.size(newWidth, newHeight)
                    .translate((800 - newWidth) / 2, (600 - newHeight) / 2);

                // Add picture to canvas
                canvas.add(picture);

                // IMPORTANT: Must call update() before setting frame for animations
                canvas.update();

                // Set initial frame
                // animation.frame(0);

                // Render the frame
                canvas.render();

                // Update timeline
                document.getElementById('timeline').max = info.totalFrames - 1;
                document.getElementById('timeline').value = 0;
                updateFrameInfo();

                log('✓ Animation ready to play!');
            } catch (error) {
                console.error(error);
                // log('ERROR: ' + error.message);
            }
        };

        function updateFrameInfo() {
            if (!animation) return;

            const info = animation.info();
            const frame = animation.frame();
            const time = animation.getCurrentTime();

            document.getElementById('frameInfo').textContent =
                `${frame.toFixed(1)} / ${info.totalFrames.toFixed(0)} (${time.toFixed(2)}s)`;
            document.getElementById('timeline').value = frame;
        }

        window.playPause = function() {
            if (!animation) {
                log('ERROR: No animation loaded!');
                return;
            }

            const button = document.getElementById('playBtn');

            if (animation.isPlaying()) {
                animation.pause();
                button.textContent = '▶ Play';
                log('Animation paused');
            } else {
                animation.play((frame) => {
                    // Frame callback - called on each frame update
                    // IMPORTANT: Must call update() before render() for animations
                    canvas.update();
                    canvas.render();
                    updateFrameInfo();
                });
                button.textContent = '⏸ Pause';
                log('Playing animation...');
            }
        };

        window.stop = function() {
            if (!animation) return;

            animation.stop();
            canvas.update();
            canvas.render();
            updateFrameInfo();

            const button = document.getElementById('playBtn');
            button.textContent = '▶ Play';

            log('Animation stopped');
        };

        window.prevFrame = function() {
            if (!animation) return;

            const info = animation.info();
            const currentFrame = animation.frame();
            const newFrame = Math.max(0, currentFrame - 1);

            animation.pause();
            animation.frame(newFrame);
            canvas.update();
            canvas.render();
            updateFrameInfo();

            const button = document.getElementById('playBtn');
            button.textContent = '▶ Play';
        };

        window.nextFrame = function() {
            if (!animation) return;

            const info = animation.info();
            const currentFrame = animation.frame();
            const newFrame = Math.min(info.totalFrames - 1, currentFrame + 1);

            animation.pause();
            animation.frame(newFrame);
            canvas.update();
            canvas.render();
            updateFrameInfo();

            const button = document.getElementById('playBtn');
            button.textContent = '▶ Play';
        };

        window.seekFrame = function(value) {
            if (!animation) return;

            animation.pause();
            animation.frame(parseFloat(value));
            canvas.update();
            canvas.render();
            updateFrameInfo();

            const button = document.getElementById('playBtn');
            button.textContent = '▶ Play';
        };

        window.toggleLoop = function() {
            if (!animation) return;

            const loop = document.getElementById('loopCheckbox').checked;
            animation.setLoop(loop);
            log(`Loop ${loop ? 'enabled' : 'disabled'}`);
        };

        // Auto-initialize message
        log('Ready! Click "Initialize" to start.');
    </script>
</body>
</html>
